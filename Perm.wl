BeginPackage["Peanotica`Perm`"];

PPermDisconnect[];

Scan[Unprotect@#; ClearAll@#; &, Names@{"Peanotica`Perm`*"}];

(* basic types and functions *)
NotationOfPermutation::usage = "NotationOfPermutation[perm]";
ConvertPermutationNotation::usage = "ConvertPermutationNotation[perm, notation]";
SCycles;
Images;
ToImagesNotation::usage = "ToImagesNotation[perm]";
ToSCyclesNotation::usage = "ToSCyclesNotation[perm]";
MinPermutationLength::usage = "MinPermutationLength[perm]";
ShiftPermutation::usage = "ShiftPermutation[perm, length]";
ShiftAndJoinGenSets::usage = "ShiftAndJoinGenSets[gensets, lengths]";
SignedInversePermutation::usage = "SignedInversePermutation[perm]";
SeparatePermSign::usage = "SeparatePermSign[perm]";
PPermPermutationProduct::usage = "PPermPermutationProduct[perm1, perm2, ...]";

(* predefined symmetry groups *)
SymmetricGenSet::usage = "SymmetricGenSet[n1, n2, ...]";
RiemannSymmetricGenSet::usage = "RiemannSymmetricGenSet[n1, n2, n3, n4]";
BlockSymmetricGenSet::usage = "BlockSymmetricGenSet[list1, list2, ...]";
RiemannMonomialGenSet::usage = "RiemannMonomialGenSet[n]";
ScalarMonomialDummiesGenSet::usage = "ScalarMonomialDummiesGenSet[n]";
DummiesGenSet::usage = "DummiesGenSet[sign, {{u1, d1}, ...}]";
RubiksCubeGenSet;
SymmetryOfSortedList::usage = "SymmetryOfSortedList[list]";

(* Wolfram functions *)
PermutePoint::usage = "PermutePoint[point, perm]";
OneOrbit::usage = "OneOrbit[genset, point]";
AllOrbits::usage = "";

(* WSTP functions *)
ConstructStrongGenSet::usage = "ConstructStrongGenSet[G] returns a strong generating set relative to the base [1, 2, ..., n] of the group \[LeftAngleBracket]G\[RightAngleBracket], using Jerrum's variant of Schreier-Sims algorithm.";
DoubleCosetRepresentative::usage = "DoubleCosetRepresentative[S, g, D] returns a canonical representative of the double coset \[LeftAngleBracket]S\[RightAngleBracket]\[CenterDot]g\[CenterDot]\[LeftAngleBracket]D\[RightAngleBracket] using Butler's algorithm. If two identical permutations with opposite signs are in the double coset, 0 is returned. S and D are assumed to be strong generating sets relative to the base [1, 2, ..., n] where n is the degree. The criterium is the minimum permutation in the lexicographic order of its images.";
GroupOrderFromStrongGenSet::usage = "GroupOrderFromStrongGenSet[g] gives the order of the group \[LeftAngleBracket]g\[RightAngleBracket], where g is assumed to be a strong generating set relative to the base [1, 2, ..., n].";
MoveBasePoint;
PPermGroupElements::usage = "PPermGroupElements[g] gives all the group elements generated by g.";
PPermStabilizer::usage = "PPermStabilizer[genset, p] gives a list of generators of the stabilizer.";
PPermOpenLogFile::usage = "PPermOpenLogFile[path] opens a log file for the logs to be printed.";
PPermCloseLogFile::usage = "PPermCloseLogFile[] closes the current log file."; (* defined in mathlink directly *)
DoubleTransversalInSymmetricGroup::usage = "DoubleTransversalInSymmetricGroup[S, D]";

UseTwoStep::usage = "UseTwoStep is a boolean option for DoubleCosetRepresentative specifying whether to use the two-step method described by Portugal: apply the right coset representative algorithm on the stable points of \[LeftAngleBracket]D\[RightAngleBracket] first, and then apply Butler's algorithm on the result. It's claimed that such method is more efficient, while profiling result shows otherwise. The default is False.";
PPermVerbose::usage = "PPermVerbose is a boolean option for various PPerm functions specifying whether to print messages to log file. This option is maining for debug purpose, and the messages are only enabled in debug builds. The default is False.";

(* mathlink management *)
$PPermLink::usage = "$PPermLink is a global variable holding the LinkObject of the external executable of PPerm.";
PPermConnect::usage = "PPermConnect[] creates the connection to the external executable of PPerm.";
PPermDisconnect::usage = "PPermDisconnect[] disconnects the external executable.";
PPermEnsureLink::usage = "PPermEnsureLink[] checks if $PPermLink is valid, and calls PPermConnect[] if it's not.";

Begin["`Private`"];

CheckLink;
MathLinkConstructStrongGenSet;
MathLinkDoubleCosetRepresentative;
MathLinkGroupOrderFromStrongGenSet;
MathLinkPPermGroupElements;
MathLinkPPermStabilizer;
MathLinkMoveBasePoint;
MathLinkDoubleTransversalInSymmetricGroup;
MathLinkOpenLogFile;

FormatOneCycle[cyc_List] := RowBox@Join[{"("}, Riffle[MakeBoxes /@ cyc, ","], {")"}];
SCycles /: MakeBoxes[expr_SCycles, StandardForm] := InterpretationBox[RowBox@#, expr] &@If[Length@expr === 0, {"I"}, FormatOneCycle /@ Apply[List, expr]];

NotationOfPermutation[expr_] := If[!FreeQ[expr, SCycles], SCycles, Images];
SyntaxInformation@NotationOfPermutation = {"ArgumentsPattern" -> {_}};

NonPermutationQ[a_] := With[{h = Head@a}, h =!= Images && h =!= SCycles];

PPermPermutationProduct[l___, a_ * b_?NonPermutationQ, r___] := b * PPermPermutationProduct[l, a, r];
PPermPermutationProduct[l___, e1_Images, e2_Images, r___] := PPermPermutationProduct[l, Images @@ PermutationProduct[e1, e2], r];
PPermPermutationProduct[l___, e1_SCycles, e2_Images, r___] := PPermPermutationProduct[l, SCycles @@ First@PermutationProduct[Cycles[List @@ e1], PermutationCycles[List @@ e2]], r];
PPermPermutationProduct[l___, e1_Images, e2_SCycles, r___] := PPermPermutationProduct[l, SCycles @@ First@PermutationProduct[PermutationCycles[List @@ e1], Cycles[List @@ e2]], r];
PPermPermutationProduct[l___, e1_SCycles, e2_SCycles, r___] := PPermPermutationProduct[l, SCycles @@ First@PermutationProduct[Cycles[List @@ e1], Cycles[List @@ e2]], r];
PPermPermutationProduct[] = Images[];
PPermPermutationProduct[e_] := e;
SyntaxInformation@PPermPermutationProduct = {"ArgumentsPattern" -> {___}};

ToImagesNotation[-a_] := -ToImagesNotation@a;
ToImagesNotation[SCycles[inds__]] := Images @@ PermutationList[Cycles@{inds}];
ToImagesNotation[SCycles[]] = Images[];
ToImagesNotation[a_] := a;
SyntaxInformation@ToImagesNotation = {"ArgumentsPattern" -> {_, _}};

ToSCyclesNotation[-a_] := -ToSCyclesNotation[a];
ToSCyclesNotation[Images[inds__]] := SCycles @@ First@PermutationCycles@{inds};
ToSCyclesNotation[a_] := a;
SyntaxInformation@ToSCyclesNotation = {"ArgumentsPattern" -> {_}};

MinPermutationLength[-a_] := MinPermutationLength@a;
MinPermutationLength[SCycles[]] = 0;
MinPermutationLength[SCycles[inds__]] := Max @@ Apply[Max, {inds}, {2}];
MinPermutationLength[Images[]] = 0;
MinPermutationLength[Images[inds__]] := Max[inds];
MinPermutationLength[expr_List] := Max @@ Append[Map[MinPermutationLength, expr], 0];
SyntaxInformation@MinPermutationLength = {"ArgumentsPattern" -> {_}};

ShiftPermutation[-a_, by_] := -ShiftPermutation[a, by];
ShiftPermutation[expr_List, by_] := ShiftPermutation[#, by] & /@ expr;
ShiftPermutation[expr_Images, by_] := Join[Images @@ Range@by, by + # & /@ expr];
ShiftPermutation[expr_SCycles, by_] := by + # & /@ expr;
SyntaxInformation@ShiftPermutation = {"ArgumentsPattern" -> {_, _}};

ShiftAndJoinGenSets[gensets_, lengths_] := Join @@ MapThread[ShiftPermutation, {gensets, Drop[FoldList[Plus, 0, lengths], -1]}];
SyntaxInformation@ShiftAndJoinGenSets = {"ArgumentsPattern" -> {_, _}};

SignedInversePermutation[-expr_] := -SignedInversePermutation[expr];
SignedInversePermutation[0] = 0;
SignedInversePermutation[expr_Images] := Images @@ InversePermutation[List @@ expr];
SyntaxInformation@SignedInversePermutation = {"ArgumentsPattern" -> {_}};

SymmetricGenSet[] = {};
SymmetricGenSet[points__] := MapThread[SCycles[{#1, #2}] &, {Drop[{points}, -1], Drop[{points}, 1]}];
SyntaxInformation@SymmetricGenSet = {"ArgumentsPattern" -> {__}};

RiemannSymmetricGenSet[n_] := RiemannSymmetricGenSet[n, n + 1, n + 2, n + 3];
RiemannSymmetricGenSet[n1_, n2_, n3_, n4_] := {-SCycles@{n1, n2}, -SCycles@{n3, n4}, SCycles[{n1, n3}, {n2, n4}]};
SyntaxInformation@RiemannSymmetricGenSet = {"ArgumentsPattern" -> {_, _., _., _.}};

BlockSymmetricGenSet[blocks__] := MapThread[SCycles @@ Thread[{#1, #2}] &, {Drop[{blocks}, -1], Drop[{blocks}, 1]}];
BlockSymmetricGenSet[] = {};
SyntaxInformation@BlockSymmetricGenSet = {"ArgumentsPattern" -> {__}};

RiemannMonomialGenSet[n_] := With[{blocks = Partition[Range[4n], 4]}, Join[Join @@ RiemannSymmetricGenSet @@@ blocks, BlockSymmetricGenSet @@ blocks]];
SyntaxInformation@RiemannMonomialGenSet = {"ArgumentsPattern" -> {_}};

ScalarMonomialDummiesGenSet[n_] := With[{inds = Partition[Range[n], 2]}, Join[Join @@ (SymmetricGenSet @@@ inds), BlockSymmetricGenSet @@ inds]];
SyntaxInformation@ScalarMonomialDummiesGenSet = {"ArgumentsPattern" -> {_}};

DummiesGenSet[sign_, dummies_] := Join[If[sign =!= 0, sign * Join @@ (SymmetricGenSet @@@ dummies), {}], BlockSymmetricGenSet @@ dummies];
SyntaxInformation@DummiesGenSet = {"ArgumentsPattern" -> {_, _}};

RubiksCubeGenSet[n_]

SymmetryOfSortedList[list_] := SymmetryOfSortedList[list, SameQ];
SymmetryOfSortedList[list_, eq_] := Join @@ MapThread[If[eq[#1, #2], {SCycles@{#3, #3 + 1}}, {}] &, {Delete[list, -1], Delete[list, 1], Range[Length@list - 1]}];
SyntaxInformation@SymmetryOfSortedList = {"ArgumentsPattern" -> {_, _.}};

PermutePoint[point_, img_Images * _.] := If[point <= Length@img, img[[point]], point];
PermutePoint[point_, c_SCycles * _.] := PermutePoint[point, Images @@ PermutationList[Cycles[List @@ c]]];
PermutePoint[point_, genset_List] := PermutePoint[point, #] & /@ genset;
SyntaxInformation@PermutePoint = {"ArgumentsPattern" -> {_, _}};

OneOrbitStep[genset_][{points_, step_}] := With[{nextStep = Complement[Union @@ (PermutePoint[#, genset] & /@ step), points]}, {Join[points, nextStep], nextStep}];
OneOrbit[genset_, point_Integer] := NestWhile[OneOrbitStep[genset], {{}, {point}}, Length@#[[2]] > 0 &][[1]];
AllOrbitStep[genset_][{}, nextPoint_];
OneOrbit[genset_, points_List] := Fold[];
SyntaxInformation@OneOrbit = {"ArgumentsPattern" -> {_, _}};

PermToMLPerm[Images[inds__]] := {1, inds};
PermToMLPerm[-Images[inds__]] := {-1, inds};
PermToMLPerm[e_SCycles] := PermToMLPerm@ToImagesNotation@e;
PermToMLPerm[-e_SCycles] := PermToMLPerm@ToImagesNotation[-e];
PermToMLPerm[e_List] := PermToMLPerm /@ e;
MLPermToPerm[{n_, inds__}] := n * Images[inds];
MLPermToPerm[0] = 0;

SeparatePermSign[0] = 0;
SeparatePermSign[-a_] := {-1, a};
SeparatePermSign[a_] := {1, a};
SyntaxInformation@SeparatePermSign = {"ArgumentsPattern" -> {_}};

ConstructStrongGenSet[gs_] := (
    PPermEnsureLink[];
    ToSCyclesNotation /@ MLPermToPerm /@ MathLinkConstructStrongGenSet[PermToMLPerm@gs, MinPermutationLength@gs]
);
SyntaxInformation@ConstructStrongGenSet = {"ArgumentsPattern" -> {_, _.}};

Options[DoubleCosetRepresentative] = {
    UseTwoStep -> False,
    PPermVerbose -> False
};
DoubleCosetRepresentative[s_, g_, d_, opt : OptionsPattern[]] := With[{
    n = Max[MinPermutationLength[s], MinPermutationLength[g], MinPermutationLength[d]]
},
    PPermEnsureLink[];
    MLPermToPerm@MathLinkDoubleCosetRepresentative[PermToMLPerm@s, PermToMLPerm@g, PermToMLPerm@d, n, Boole[OptionValue[UseTwoStep]], Boole[OptionValue[PPermVerbose]]]
];
SyntaxInformation@DoubleCosetRepresentative = {"ArgumentsPattern" -> {_, _, _, OptionsPattern[]}};

DoubleTransversalInSymmetricGroup[s_, d_] := With[{
    n = Max[MinPermutationLength@s, MinPermutationLength@d]
},
    PPermEnsureLink[];
    MLPermToPerm /@ MathLinkDoubleTransversalInSymmetricGroup[n, PermToMLPerm@s, PermToMLPerm@d]
];
SyntaxInformation@DoubleTransversalInSymmetricGroup = {"ArgumentsPattern" -> {_, _}};

GroupOrderFromStrongGenSet[gs_] := (
    PPermEnsureLink[];
    MathLinkGroupOrderFromStrongGenSet[PermToMLPerm@gs, MinPermutationLength@gs]
);
SyntaxInformation@GroupOrderFromStrongGenSet = {"ArgumentsPattern" -> {_}};

MoveBasePoint[base_, gs_, pos_] := (
    PPermEnsureLink[];
    ToSCyclesNotation /@ MLPermToPerm /@ MathLinkMoveBasePoint[base, PermToMLPerm@gs, pos, Max[MinPermutationLength@gs, Max @@ base]]
);

PPermGroupElements[genset_List] := (
    PPermEnsureLink[];
    MLPermToPerm /@ MathLinkPPermGroupElements[PermToMLPerm@genset, MinPermutationLength@genset]
);
SyntaxInformation@PPermGroupElements = {"ArgumentsPattern" -> {_}};

PPermStabilizer[genset_List, point_Integer] := (
    PPermEnsureLink[];
    MLPermToPerm /@ MathLinkPPermStabilizer[MinPermutationLength@genset, PermToMLPerm@genset, point]
);
SyntaxInformation@PPermStabilizer = {"ArgumentsPattern" -> {_, _}};

PPermDisconnect[] := If[Head@$PPermLink === LinkObject, Quiet[Uninstall@$PPermLink, LinkObject::linkn]; $PPermLink =.];
SyntaxInformation@PPermDisconnect = {"ArgumentsPattern" -> {}};

PPermConnect[] := (
    PPermDisconnect[];
    $PPermLink = Install@FileNameJoin[{DirectoryName@FindFile["Peanotica`Perm`"], "mathlink", "pperm-ml"}]
);
SyntaxInformation@PPermConnect = {"ArgumentsPattern" -> {}};

PPermEnsureLink::reconn = "Link is dead, trying to reconnect.";
PPermEnsureLink[] := With[{chk = CheckLink[]}, If[chk =!= True, If[chk === $Failed, Message[PPermEnsureLink::reconn]]; PPermConnect[]]];
SyntaxInformation@PPermEnsureLink = {"ArgumentsPattern" -> {}};

PPermOpenLogFile[path_] := (
    PPermEnsureLink[];
    MathLinkOpenLogFile[path];
);
SyntaxInformation@PPermOpenLogFile = {"ArgumentsPattern" -> {_}};

End[];

Protect @@ Complement[Names["`*"], {"$PPermLink", "PPermCloseLogFile"}];

EndPackage[];